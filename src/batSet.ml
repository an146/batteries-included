(* 
 * ExtSet - Extended operations on sets
 * Copyright (C) 1996 Xavier Leroy
 *               2009 David Rajchenbach-Teller, LIFO, Universite d'Orleans
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)


module type OrderedType = BatInterfaces.OrderedType
(** Input signature of the functor {!Set.Make}. *)


module type S_root =
  sig
    include Set.S

    val compare_subset: t -> t -> int
    (** Partial ordering between sets as generated by [subset] *)

    val map: (elt -> elt) -> t -> t
      (** [map f x] creates a new set with elements [f a0],
	  [f a1]... [f an], where [a1], ..., [an] are the
	  values contained in [x]*)

    val filter_map: (elt -> elt option) -> t -> t
      (** [filter_map f m] combines the features of [filter] and
	  [map].  It calls calls [f a0], [f a1], [f an] where [a0..an]
	  are the elements of [m] and returns the set of pairs [bi]
	  such as [f ai = Some bi] (when [f] returns [None], the
	  corresponding element of [m] is discarded). *)

    val fold_left : ('a -> elt -> 'a) -> 'a -> t -> 'a
      (** as {!Set.fold} but different order arguments, same order of
	  application *)

    val enum: t -> elt BatEnum.t
      (** Return an enumeration of all elements of the given set.
	  The returned enumeration is sorted in increasing order with respect
	  to the ordering [Ord.compare], where [Ord] is the argument
	  given to {!Set.Make}. *)

    val backwards: t -> elt BatEnum.t
      (** Return an enumeration of all elements of the given set.
	  The returned enumeration is sorted in decreasing order with respect
	  to the ordering [Ord.compare], where [Ord] is the argument
	  given to {!Set.Make}. *)

    val of_enum: elt BatEnum.t -> t

    module StdSet : Set.S

    val to_stdset : t -> StdSet.t
      (** Convert a batteries set into a stdlib set *)


    (** {6 Boilerplate code}*)

    (** {6 Override modules}*)
      
    (** Operations on {!Set} without exceptions.*)
    module Exceptionless : sig
      val min_elt: t -> elt option
      val max_elt: t -> elt option
      val choose:  t -> elt option
    end
      
      
    (** Operations on {!Set} with labels.
	
	This module overrides a number of functions of {!Set} by
	functions in which some arguments require labels. These labels are
	there to improve readability and safety and to let you change the
	order of arguments to functions. In every case, the behavior of the
	function is identical to that of the corresponding function of {!Set}.
    *)
    module Labels : sig
      val iter : f:(elt -> unit) -> t -> unit
      val fold : f:(elt -> 'a -> 'a) -> t -> init:'a -> 'a
      val for_all : f:(elt -> bool) -> t -> bool
      val exists : f:(elt -> bool) -> t -> bool
      val map: f:(elt -> elt) -> t -> t
      val filter : f:(elt -> bool) -> t -> t
      val filter_map: f:(elt -> elt option) -> t -> t
      val partition : f:(elt -> bool) -> t -> t * t
    end
      
  end
    (** Output signature of the functor {!Set.Make}. *)

module type S = sig
  include S_root
  (** {7 Printing}*)
    
  val print :  ?first:string -> ?last:string -> ?sep:string -> 
    ('a BatInnerIO.output -> elt -> unit) -> 
    'a BatInnerIO.output -> t -> unit
end

module type PS = sig
  include S_root
    
  (** {7 Printing}*)
    
  val print :  ?first:string -> ?last:string -> ?sep:string -> 
    'a BatInnerIO.output -> t -> unit
end


module Make(Ord:OrderedType) =
  struct
    type elt = Ord.t
    type t = Empty | Node of t * elt * t * int

    (* Sets are represented by balanced binary trees (the heights of the
       children differ by at most 2 *)

    let height = function
        Empty -> 0
      | Node(_, _, _, h) -> h

    (* Creates a new node with left son l, value v and right son r.
       We must have all elements of l < v < all elements of r.
       l and r must be balanced and | height l - height r | <= 2.
       Inline expansion of height for better speed. *)

    let create l v r =
      let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h in
      let hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
      Node(l, v, r, (if hl >= hr then hl + 1 else hr + 1))

    (* Same as create, but performs one step of rebalancing if necessary.
       Assumes l and r balanced and | height l - height r | <= 3.
       Inline expansion of create for better speed in the most frequent case
       where no rebalancing is required. *)

    let bal l v r =
      let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h in
      let hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
      if hl > hr + 2 then begin
        match l with
          Empty -> invalid_arg "Set.bal"
        | Node(ll, lv, lr, _) ->
            if height ll >= height lr then
              create ll lv (create lr v r)
            else begin
              match lr with
                Empty -> invalid_arg "Set.bal"
              | Node(lrl, lrv, lrr, _)->
                  create (create ll lv lrl) lrv (create lrr v r)
            end
      end else if hr > hl + 2 then begin
        match r with
          Empty -> invalid_arg "Set.bal"
        | Node(rl, rv, rr, _) ->
            if height rr >= height rl then
              create (create l v rl) rv rr
            else begin
              match rl with
                Empty -> invalid_arg "Set.bal"
              | Node(rll, rlv, rlr, _) ->
                  create (create l v rll) rlv (create rlr rv rr)
            end
      end else
        Node(l, v, r, (if hl >= hr then hl + 1 else hr + 1))

    (* Insertion of one element *)

    let rec add x = function
        Empty -> Node(Empty, x, Empty, 1)
      | Node(l, v, r, _) as t ->
          let c = Ord.compare x v in
          if c = 0 then t else
          if c < 0 then bal (add x l) v r else bal l v (add x r)

    (* Same as create and bal, but no assumptions are made on the
       relative heights of l and r. *)

    let rec join l v r =
      match (l, r) with
        (Empty, _) -> add v r
      | (_, Empty) -> add v l
      | (Node(ll, lv, lr, lh), Node(rl, rv, rr, rh)) ->
          if lh > rh + 2 then bal ll lv (join lr v r) else
          if rh > lh + 2 then bal (join l v rl) rv rr else
          create l v r

    (* Smallest and greatest element of a set *)

    let rec min_elt = function
        Empty -> raise Not_found
      | Node(Empty, v, r, _) -> v
      | Node(l, v, r, _) -> min_elt l

    let rec max_elt = function
        Empty -> raise Not_found
      | Node(l, v, Empty, _) -> v
      | Node(l, v, r, _) -> max_elt r

    (* Remove the smallest element of the given set *)

    let rec remove_min_elt = function
        Empty -> invalid_arg "Set.remove_min_elt"
      | Node(Empty, v, r, _) -> r
      | Node(l, v, r, _) -> bal (remove_min_elt l) v r

    (* Merge two trees l and r into one.
       All elements of l must precede the elements of r.
       Assume | height l - height r | <= 2. *)

    let merge t1 t2 =
      match (t1, t2) with
        (Empty, t) -> t
      | (t, Empty) -> t
      | (_, _) -> bal t1 (min_elt t2) (remove_min_elt t2)

    (* Merge two trees l and r into one.
       All elements of l must precede the elements of r.
       No assumption on the heights of l and r. *)

    let concat t1 t2 =
      match (t1, t2) with
        (Empty, t) -> t
      | (t, Empty) -> t
      | (_, _) -> join t1 (min_elt t2) (remove_min_elt t2)

    (* Splitting.  split x s returns a triple (l, present, r) where
        - l is the set of elements of s that are < x
        - r is the set of elements of s that are > x
        - present is false if s contains no element equal to x,
          or true if s contains an element equal to x. *)

    let rec split x = function
        Empty ->
          (Empty, false, Empty)
      | Node(l, v, r, _) ->
          let c = Ord.compare x v in
          if c = 0 then (l, true, r)
          else if c < 0 then
            let (ll, pres, rl) = split x l in (ll, pres, join rl v r)
          else
            let (lr, pres, rr) = split x r in (join l v lr, pres, rr)

    (* Implementation of the set operations *)

    let empty = Empty

    let is_empty = function Empty -> true | _ -> false

    let rec mem x = function
        Empty -> false
      | Node(l, v, r, _) ->
          let c = Ord.compare x v in
          c = 0 || mem x (if c < 0 then l else r)

    let singleton x = Node(Empty, x, Empty, 1)

    let rec remove x = function
        Empty -> Empty
      | Node(l, v, r, _) ->
          let c = Ord.compare x v in
          if c = 0 then merge l r else
          if c < 0 then bal (remove x l) v r else bal l v (remove x r)

    let rec union s1 s2 =
      match (s1, s2) with
        (Empty, t2) -> t2
      | (t1, Empty) -> t1
      | (Node(l1, v1, r1, h1), Node(l2, v2, r2, h2)) ->
          if h1 >= h2 then
            if h2 = 1 then add v2 s1 else begin
              let (l2, _, r2) = split v1 s2 in
              join (union l1 l2) v1 (union r1 r2)
            end
          else
            if h1 = 1 then add v1 s2 else begin
              let (l1, _, r1) = split v2 s1 in
              join (union l1 l2) v2 (union r1 r2)
            end

    let rec inter s1 s2 =
      match (s1, s2) with
        (Empty, t2) -> Empty
      | (t1, Empty) -> Empty
      | (Node(l1, v1, r1, _), t2) ->
          match split v1 t2 with
            (l2, false, r2) ->
              concat (inter l1 l2) (inter r1 r2)
          | (l2, true, r2) ->
              join (inter l1 l2) v1 (inter r1 r2)

    let rec diff s1 s2 =
      match (s1, s2) with
        (Empty, t2) -> Empty
      | (t1, Empty) -> t1
      | (Node(l1, v1, r1, _), t2) ->
          match split v1 t2 with
            (l2, false, r2) ->
              join (diff l1 l2) v1 (diff r1 r2)
          | (l2, true, r2) ->
              concat (diff l1 l2) (diff r1 r2)

    type enumeration = End | More of elt * t * enumeration

    let rec cons_enum s e =
      match s with
        Empty -> e
      | Node(l, v, r, _) -> cons_enum l (More(v, r, e))

    let rec compare_aux e1 e2 =
        match (e1, e2) with
        (End, End) -> 0
      | (End, _)  -> -1
      | (_, End) -> 1
      | (More(v1, r1, e1), More(v2, r2, e2)) ->
          let c = Ord.compare v1 v2 in
          if c <> 0
          then c
          else compare_aux (cons_enum r1 e1) (cons_enum r2 e2)

    let compare s1 s2 =
      compare_aux (cons_enum s1 End) (cons_enum s2 End)

    let equal s1 s2 =
      compare s1 s2 = 0

    let rec subset s1 s2 =
      match (s1, s2) with
        Empty, _ ->
          true
      | _, Empty ->
          false
      | Node (l1, v1, r1, _), (Node (l2, v2, r2, _) as t2) ->
          let c = Ord.compare v1 v2 in
          if c = 0 then
            subset l1 l2 && subset r1 r2
          else if c < 0 then
            subset (Node (l1, v1, Empty, 0)) l2 && subset r1 t2
          else
            subset (Node (Empty, v1, r1, 0)) r2 && subset l1 t2

    let rec iter f = function
        Empty -> ()
      | Node(l, v, r, _) -> iter f l; f v; iter f r

    let rec fold f s accu =
      match s with
        Empty -> accu
      | Node(l, v, r, _) -> fold f r (f v (fold f l accu))

    let rec for_all p = function
        Empty -> true
      | Node(l, v, r, _) -> p v && for_all p l && for_all p r

    let rec exists p = function
        Empty -> false
      | Node(l, v, r, _) -> p v || exists p l || exists p r

    let filter p s =
      let rec filt accu = function
        | Empty -> accu
        | Node(l, v, r, _) ->
            filt (filt (if p v then add v accu else accu) l) r in
      filt Empty s

    let partition p s =
      let rec part (t, f as accu) = function
        | Empty -> accu
        | Node(l, v, r, _) ->
            part (part (if p v then (add v t, f) else (t, add v f)) l) r in
      part (Empty, Empty) s

    let rec cardinal = function
        Empty -> 0
      | Node(l, v, r, _) -> cardinal l + 1 + cardinal r

    let rec elements_aux accu = function
        Empty -> accu
      | Node(l, v, r, _) -> elements_aux (v :: elements_aux accu r) l

    let elements s =
      elements_aux [] s

    let choose = min_elt


(*    let enum t =
      let queue = Queue.create () in
      let rec next () = 
	let item =
	  try Queue.pop queue
	  with Queue.Empty ->
	    raise BatEnum.No_more_elements
	in
	match item with
	  | Empty -> next ()
	  | Node (l, e, r, _) ->
	      Queue.push l queue;
	      Queue.push r queue;
	      e
      in Queue.add (impl_of_t t) queue;
	BatEnum.from next*)

    let rec fold_left f accu s =
      match s with
        Empty -> accu
      | Node(l, v, r, _) -> fold_left f r (f (fold_left f l accu) v)

    open Printf
    (* s1 in s2 -> -1, s2 in s1 -> 1, neither a subset -> min_int, eq -> 0 *)
    let rec compare_subset s1 s2 =
      match (s1, s2) with
	  (Empty, Empty) -> 0
	| (Empty, t2) -> -1
	| (t1, Empty) -> 1
	| (Node(l1, v1, r1, _), t2) ->
            match split v1 t2 with
		(l2, true, r2) -> (* v1 in both s1 and s2 *)
		  ( match compare_subset l1 l2, compare_subset r1 r2 with
		      | -1, -1 | -1, 0 | 0, -1 -> -1
		      | 0, 0 -> 0
		      | 1, 1 | 1, 0 | 0, 1 -> 1
		      | _ -> min_int
		  )
              | (l2, false, r2) -> (* v1 in s1, but not in s2 *)
		  if (compare_subset l1 l2) >= 0 && (compare_subset r1 r2) >= 0
		  then 1 else min_int

    type iter = E | C of elt * t * iter

    let rec cons_iter s t = match s with
        Empty -> t
      | Node (l, e, r, _) -> cons_iter l (C (e, r, t))

    let rec rev_cons_iter s t = match s with
        Empty -> t
      | Node (l, e, r, _) -> rev_cons_iter r (C (e, l, t))

    let rec enum_next l () = match !l with
        E -> raise BatEnum.No_more_elements
      | C (e, s, t) -> l := cons_iter s t; e

    let rec enum_backwards_next l () = match !l with
        E -> raise BatEnum.No_more_elements
      | C (e, s, t) -> l := rev_cons_iter s t; e

    let rec enum_count l () =
      let rec aux n = function
          E -> n
        | C (e, s, t) -> aux (n + 1 + cardinal s) t
      in aux 0 !l

    let enum t =
      let rec make l =
        let l = ref l in
        let clone() = make !l in
          BatEnum.make ~next:(enum_next l) ~count:(enum_count l) ~clone
      in make (cons_iter t E)

    let backwards t =
      let rec make l =
        let l = ref l in
        let clone() = make !l in
          BatEnum.make ~next:(enum_backwards_next l) ~count:(enum_count l) ~clone
      in make (rev_cons_iter t E)

    let of_enum e = 
      BatEnum.fold (fun acc elem -> add elem acc) empty e

    let map f e = fold (fun x acc -> add (f x) acc) e empty
	
    let filter f e = fold (fun x acc -> if f x then add x acc else acc) e empty

    let filter_map f e = fold (fun x acc -> match f x with Some v -> add v acc | _ -> acc) e empty

    let print ?(first="{\n") ?(last="\n}") ?(sep=",\n") print_elt out t =
      BatEnum.print ~first ~last ~sep print_elt out (enum t)

    module StdSet = Set.Make(Ord)
    external to_stdset : t -> StdSet.t = "%identity"

	
    module Exceptionless =
    struct
      let min_elt t = try Some (min_elt t) with Not_found -> None
      let max_elt t = try Some (max_elt t) with Not_found -> None
      let choose  t = try Some (choose t)  with Not_found -> None
    end

    module Labels =
    struct
      let iter ~f t = iter f t
      let fold ~f t ~init = fold f t init
      let for_all ~f t    = for_all f t
      let exists ~f t     = exists f t
      let map    ~f t     = map f t
      let filter ~f t     = filter f t
      let filter_map ~f t = filter_map f t
      let partition ~f t  = partition f t
    end
  end

module Make_printable(E:BatInterfaces.OrderedPrintable) = 
struct
  include Make(E)
    
  let print ?(first="{\n") ?(last="\n}") ?(sep=",\n") out t =
    BatEnum.print ~first ~last ~sep E.print out (enum t)
end


  module StringSet  = Make_printable(struct include String include BatString end)

  module IStringSet = Make_printable(BatString.IString)

  module NumStringSet = Make_printable(BatString.NumString)

  module RopeSet    = Make_printable(BatRope)

  module IRopeSet   = Make_printable(BatRope.IRope)

  module IntSet     = Make_printable(BatInt)
